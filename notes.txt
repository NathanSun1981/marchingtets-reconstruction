1. I changed the search_within_radius function so that it uses a kdtree to perform range searches
2. in compute_implicit_function_values we need to perform range searches which is now using a kdtree.
However, the point is that it doesn't matter if result points are already visited or not. Therefore, it
can easily get parallelized!
3. I added a new argument to the kdtree's range_nearest_neighbors function called unique. This boolean indicates
if uniqueness of the result matters to us or not.
4. try to further imporve the merge_vertices function. it's the major bottle neck.
5. how to add additional flags rather than -g which is for debug?
6. now that debug mode is enabled, profile it using valgrind
7. replace_value is the major bottleneck now (M.rows() = 19134, M.cols() = 3 and vals.size() <= 10)